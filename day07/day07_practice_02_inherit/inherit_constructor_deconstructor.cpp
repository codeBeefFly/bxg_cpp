/*

需求：
简单的继承
类中么有成员
查看调用顺序



 * 继承状态下的父子类析构函数调用顺序
 *  构造函数： 晓爽
 *         结论：先走父亲的构造函数，再走孩子的构造函数
 *
 *         原因：构造函数都是用来初始化的，那么在子类当中有可能会用到父亲的一些成员。
 *              或者是在执行子类构造之前，有一些准备工作必须要事先完成。 那么这些工作可以
 *              在父类的构造里面实现。（尤其是对成员进行初始化。）
 *
 *  析构函数：  陈科 & 孙克
 *         结论： 先走子类的析构函数，再走父类的析构函数。
 *
 *         原因：因为从范围角度而言，父亲的范围更大一些。一般销毁的时候，是由内而外，
 *              一层一层的子销毁，更彻底一些，举个例子：平常关电脑。？长按电源键，
 *
 *              因为父亲里面可能存放的着一些数据，并且这些数据，在子类里面还用着。
 *              如果贸然销毁了父亲，在来销毁子类，可能会导致出问题。


*/		   

#include <iostream>


class Father {
public:

	Father() {
		std::cout << "..父类构造函数...\n";
	};
	
	~Father() {
		std::cout << "..父类析构函数...\n";
	};
};


class Son : public Father {
public:

	Son() {
		std::cout << "..子类构造函数...\n";
	};

	~Son() {
		std::cout << "..子类析构函数...\n";
	};
};



int main() {

	std::cout << "..in inherit_constructor_deocnstructor...\n";

	Son s;


	return 0;
}



/*

output 


..in inherit_constructor_deocnstructor...
..父类构造函数...
..子类构造函数...
..子类析构函数...
..父类析构函数...

*/