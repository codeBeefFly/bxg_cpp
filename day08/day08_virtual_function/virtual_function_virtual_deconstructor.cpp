/*

需求：

一句话概括： 继承关系下，所有人的构造都不能是虚函数，并且所有人的析构函数都必须是虚函数。

只要在父亲的析构函数加上 virtual ，那么所有的析构函数都变成 虚函数


*/



#include <iostream>
#include <string>

using namespace std;

/**
 * 虚函数
 *      1. 构造函数能不能是虚函数？
 *          结论： 构造函数不能是虚函数.
 *          原因： 刚才说过了，虚函数是为与对象开辟的空间里面有一个指针，这个指针
 *              指向了虚函数的地址。而构造函数正是用于创建对象，对象都没有创建出来
 *              那么这个虚函数表的这个指针，怎么放呢。
 *      2. 析构函数呢
 *          结论： 析构函数可以是虚函数。
 *          问题：必须是虚函数吗？不是行不行？
 *              也不一定，如果是一个很干净的，独立的类。那么不需要把析构函数声明成虚函数。
 *              如果是存在继承间关系，那么就需要把父类的析构函数标记成虚函数。
 *              否则当使用父类的指针接收子类对象的时候，销毁该对象，并不会执行子类的析构。
 *              本来创建的是子类的对象，结构走的却只有父类的析构，这是不合常理的。
 *
 */

class father {
public:
    father() {
        cout << "父亲的构造" << endl;
    }
    virtual ~father() {
        cout << "父亲的析构" << endl;
    }
};

class son : public father {
public:
    son() {
        cout << "孩子的构造" << endl;
    }
    //virtual ~son() {
    ~son() {
        cout << "孩子的析构" << endl;
    }


    /*
    析构函数的 virtual 是自动加上的，结果不变

    父亲的构造
    孩子的构造
    孩子的析构
    父亲的析构

    */
};

int main() {

    /* father * f = new father();
     delete f;

     son * s = new son();
     delete s;*/

    father* fs = new son(); //走孩子的构造。
    delete fs;  //走孩子的析构。

    return 0;
}


/*

output


父亲的构造
孩子的构造
孩子的析构
父亲的析构


*/